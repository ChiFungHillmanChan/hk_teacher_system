// src/pages/analysation/ExcelParser.js
import Papa from 'papaparse';
import readXlsxFile from 'read-excel-file';
import { GRADE_MAP, HEADER_SYNONYMS } from './utils/Config';
import { fuzzyMatchHeader, normalizeString } from './utils/Utils';

const ExcelParser = {
  /**
   * Parse Excel/CSV file and return raw model with schools and students
   * @param {File} file - The uploaded file
   * @returns {Promise<Object>} Raw model with schools array
   */
  parseFile: async file => {
    console.log('[ExcelParser] üìä ÈñãÂßãËß£ÊûêÊ™îÊ°à:', file.name);

    try {
      // Extract data based on file type
      let rawData;
      if (file.type === 'text/csv' || file.name.toLowerCase().endsWith('.csv')) {
        rawData = await ExcelParser.parseCSV(file);
      } else if (file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
        rawData = await ExcelParser.parseExcel(file);
      } else {
        throw new Error('‰∏çÊîØÊè¥ÁöÑÊ™îÊ°àÊ†ºÂºè„ÄÇË´ã‰∏äÂÇ≥ CSV„ÄÅXLSX Êàñ XLS Ê™îÊ°à„ÄÇ');
      }

      console.log('[ExcelParser] üìã ÂéüÂßãË≥áÊñôË°åÊï∏:', rawData.length);

      // Process the raw data
      const processedModel = ExcelParser.processRawData(rawData);

      console.log('[ExcelParser] üè´ ÂÅµÊ∏¨Âà∞Â≠∏Ê†°Êï∏Èáè:', processedModel.schools.length);
      console.log(
        '[ExcelParser] üë• Á∏ΩÂ≠∏ÁîüÊï∏Èáè:',
        processedModel.schools.reduce((total, school) => total + school.students.length, 0)
      );

      return processedModel;
    } catch (error) {
      console.error('[ExcelParser] ‚ùå Ëß£ÊûêÂ§±Êïó:', error);
      throw new Error(`Ê™îÊ°àËß£ÊûêÂ§±Êïó: ${error.message}`);
    }
  },

  /**
   * Parse CSV file using Papa Parse (secure)
   */
  parseCSV: async file => {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: false,
        skipEmptyLines: true,
        encoding: 'UTF-8',
        dynamicTyping: false, // Prevent automatic type conversion for security
        delimitersToGuess: [',', '\t', '|', ';'],
        complete: results => {
          if (results.errors.length > 0) {
            console.warn('[ExcelParser] ‚ö†Ô∏è CSV Ëß£ÊûêË≠¶Âëä:', results.errors);
          }
          resolve(results.data);
        },
        error: error => {
          reject(new Error(`CSV Ëß£ÊûêÈåØË™§: ${error.message}`));
        },
      });
    });
  },

  /**
   * Parse Excel file using read-excel-file (secure alternative to xlsx)
   */
  parseExcel: async file => {
    try {
      console.log('[ExcelParser] üìà ‰ΩøÁî®ÂÆâÂÖ®ÁöÑ Excel Ëß£ÊûêÂô®');

      // Use read-excel-file which is more secure than xlsx
      const rows = await readXlsxFile(file, {
        sheet: 1, // First sheet
        transformData: data => {
          // Convert all cells to strings for consistency and security
          return data.map(row =>
            row.map(cell => {
              if (cell === null || cell === undefined) return '';
              return String(cell).trim();
            })
          );
        },
      });

      return rows;
    } catch (error) {
      console.error('[ExcelParser] ‚ùå Excel Ëß£ÊûêÈåØË™§:', error);
      throw new Error(`Excel Ëß£ÊûêÈåØË™§: ${error.message}`);
    }
  },

  /**
   * Process raw data into schools and students model
   */
  processRawData: rawData => {
    if (!rawData || rawData.length === 0) {
      throw new Error('Ê™îÊ°àÂÖßÂÆπÁÇ∫Á©∫');
    }

    // Validate data structure
    if (!Array.isArray(rawData)) {
      throw new Error('Ê™îÊ°àÊ†ºÂºèÁÑ°Êïà');
    }

    // Extract headers and normalize them
    const headers = rawData[0];
    if (!Array.isArray(headers)) {
      throw new Error('ÁÑ°Ê≥ïËÆÄÂèñÊ™îÊ°àÊ®ôÈ°åË°å');
    }

    console.log('[ExcelParser] üìù ÂéüÂßãÊ®ôÈ°å:', headers);

    const normalizedHeaders = ExcelParser.normalizeHeaders(headers);
    console.log('[ExcelParser] üìù Ê®ôÈ°åÊò†Â∞Ñ:', normalizedHeaders);

    // Validate required columns
    ExcelParser.validateRequiredColumns(normalizedHeaders);

    // Process data rows
    const dataRows = rawData.slice(1);
    console.log(`[ExcelParser] üìä ËôïÁêÜ ${dataRows.length} Ë°åË≥áÊñô`);

    const groupedData = ExcelParser.groupDataBySchool(dataRows, normalizedHeaders);
    console.log(`[ExcelParser] üè´ ÂàÜÁµÑÂæåÂæóÂà∞ ${groupedData.length} ÂÄãÂ≠∏Ê†°Áæ§ÁµÑ`);

    // Convert to schools model
    const schools = ExcelParser.convertToSchoolsModel(groupedData);
    console.log(`[ExcelParser] ‚úÖ ËΩâÊèõÂÆåÊàêÔºåÊúÄÁµÇ ${schools.length} ÊâÄÂ≠∏Ê†°`);

    return { schools };
  },

  /**
   * Normalize headers using synonyms and fuzzy matching
   */
  normalizeHeaders: headers => {
    const normalized = {};
    const headerMap = {};

    headers.forEach((header, index) => {
      if (!header || typeof header !== 'string') return;

      const cleanHeader = normalizeString(header);
      let mappedField = null;

      // Try exact synonym match first
      for (const [standardField, synonyms] of Object.entries(HEADER_SYNONYMS)) {
        if (synonyms.includes(cleanHeader) || standardField === cleanHeader) {
          mappedField = standardField;
          break;
        }
      }

      // Try partial matching if no exact match
      if (!mappedField) {
        for (const [standardField, synonyms] of Object.entries(HEADER_SYNONYMS)) {
          // Check if header contains any of the synonyms
          const hasPartialMatch = synonyms.some(
            synonym => cleanHeader.includes(synonym) || synonym.includes(cleanHeader)
          );

          if (hasPartialMatch) {
            mappedField = standardField;
            console.log(`[ExcelParser] üîç ÈÉ®ÂàÜÂåπÈÖç: "${cleanHeader}" ‚Üí "${standardField}"`);
            break;
          }
        }
      }

      // Try fuzzy matching if still no match
      if (!mappedField) {
        mappedField = fuzzyMatchHeader(cleanHeader, HEADER_SYNONYMS);
      }

      // Try semantic matching for common variations
      if (!mappedField) {
        if (cleanHeader.includes('Â≠∏Ê†°') || cleanHeader.includes('Ê†°Âêç')) {
          mappedField = 'Â≠∏Ê†°';
        } else if (cleanHeader.includes('Â≠∏Áîü') && cleanHeader.includes('ÂßìÂêç')) {
          mappedField = 'ÂßìÂêç';
        } else if (cleanHeader.includes('Âπ¥Á¥ö') || cleanHeader.includes('Á¥öÂà•')) {
          mappedField = 'Âπ¥Á¥ö';
        } else if (cleanHeader.includes('Áè≠Âà•') || cleanHeader.includes('Áè≠Á¥ö')) {
          mappedField = 'Áè≠Âà•';
        } else if (cleanHeader.includes('È°ûÂà•') || cleanHeader.includes('È°ûÂûã')) {
          mappedField = 'Â≠∏Ê†°È°ûÂà•';
        }

        if (mappedField) {
          console.log(`[ExcelParser] üß† Ë™ûÁæ©ÂåπÈÖç: "${cleanHeader}" ‚Üí "${mappedField}"`);
        }
      }

      if (mappedField) {
        normalized[mappedField] = index;
        headerMap[index] = mappedField;
      } else {
        console.warn('[ExcelParser] ‚ö†Ô∏è Êú™ËÉΩÊò†Â∞ÑÊ®ôÈ°å:', cleanHeader);
      }
    });

    return { normalized, headerMap };
  },

  /**
   * Validate that required columns are present
   */
  validateRequiredColumns: normalizedHeaders => {
    const required = ['ÂßìÂêç', 'Â≠∏Ê†°'];

    console.log('[ExcelParser] üîç Ë™øË©¶‰ø°ÊÅØ:');
    console.log('- normalizedHeaders:', normalizedHeaders);
    console.log('- normalizedHeaders.normalized:', normalizedHeaders.normalized);
    console.log('- Ê™¢Êü•Â≠∏Ê†°Ê¨Ñ‰Ωç:', 'Â≠∏Ê†°' in normalizedHeaders.normalized);
    console.log('- Ê™¢Êü•ÂßìÂêçÊ¨Ñ‰Ωç:', 'ÂßìÂêç' in normalizedHeaders.normalized);

    const missing = required.filter(field => {
      const exists = field in normalizedHeaders.normalized;
      console.log(`- Ê¨Ñ‰Ωç "${field}" Â≠òÂú®: ${exists}`);
      return !exists;
    });

    if (missing.length > 0) {
      console.error('[ExcelParser] ‚ùå Áº∫Â∞ëÂøÖË¶ÅÊ¨Ñ‰Ωç:', missing);
      console.log('[ExcelParser] üìã Â∑≤ÊâæÂà∞ÁöÑÊ¨Ñ‰Ωç:', Object.keys(normalizedHeaders.normalized));
      throw new Error(`Áº∫Â∞ëÂøÖË¶ÅÊ¨Ñ‰Ωç: ${missing.join(', ')}`);
    }

    console.log('[ExcelParser] ‚úÖ ÊâÄÊúâÂøÖË¶ÅÊ¨Ñ‰ΩçÂ∑≤ÊâæÂà∞:', Object.keys(normalizedHeaders.normalized));
  },

  /**
   * Group data rows by school with propagation logic
   */
  groupDataBySchool: (dataRows, normalizedHeaders) => {
    const { normalized } = normalizedHeaders;
    const schoolGroups = new Map();
    let currentSchool = null;
    let currentSchoolType = null;

    dataRows.forEach((row, rowIndex) => {
      if (!Array.isArray(row)) return;

      // Extract school info
      const schoolName = normalizeString(row[normalized['Â≠∏Ê†°']] || '');
      const schoolType = normalizeString(row[normalized['Â≠∏Ê†°È°ûÂà•']] || '');

      // School propagation logic
      if (schoolName) {
        currentSchool = schoolName;
        if (schoolType) {
          currentSchoolType = schoolType;
        }
      }

      // Skip rows without school context
      if (!currentSchool) {
        console.warn(`[ExcelParser] ‚ö†Ô∏è Á¨¨ ${rowIndex + 2} Ë°åÁº∫Â∞ëÂ≠∏Ê†°Ë≥áË®äÔºåË∑≥ÈÅé`);
        return;
      }

      // Extract student data
      const studentData = ExcelParser.extractStudentData(row, normalized, rowIndex + 2);

      // Skip rows without student name
      if (!studentData.name) {
        return;
      }

      // Create school key
      const schoolKey = `${currentSchool}|${currentSchoolType || ''}`;

      // Initialize school group if needed
      if (!schoolGroups.has(schoolKey)) {
        schoolGroups.set(schoolKey, {
          name: currentSchool,
          type: currentSchoolType,
          students: [],
        });
      }

      // Add student to school
      schoolGroups.get(schoolKey).students.push(studentData);
    });

    return Array.from(schoolGroups.values());
  },

  /**
   * Convert grouped data to schools model with validation
   */
  convertToSchoolsModel: groupedData => {
    return groupedData
      .map(group => {
        // Validate group structure
        if (!group.name || !Array.isArray(group.students)) {
          console.warn('[ExcelParser] ‚ö†Ô∏è ÁÑ°ÊïàÁöÑÂ≠∏Ê†°Áæ§ÁµÑ:', group);
          return null;
        }

        // Infer school type from students if not provided
        const schoolType = ExcelParser.inferSchoolType(group.type, group.students);

        // Add duplicate hints
        const studentsWithHints = ExcelParser.generateDuplicateHints(group.students);

        return {
          name: ExcelParser.sanitizeString(group.name),
          schoolType,
          students: studentsWithHints,
          metadata: {
            studentCount: group.students.length,
            hasGrades: group.students.some(s => s.grade),
            hasClasses: group.students.some(s => s.class),
          },
        };
      })
      .filter(Boolean); // Remove null entries
  },

  /**
   * Extract student data from a row with input sanitization
   */
  extractStudentData: (row, normalized, rowNumber) => {
    const student = {
      rawRowNumber: rowNumber,
      name: ExcelParser.sanitizeString(row[normalized['ÂßìÂêç']] || ''),
      nameEn: ExcelParser.sanitizeString(row[normalized['Ëã±ÊñáÂßìÂêç']] || ''),
      grade: ExcelParser.normalizeGrade(row[normalized['Âπ¥Á¥ö']] || ''),
      class: ExcelParser.sanitizeString(row[normalized['Áè≠Âà•']] || ''),
      classNumber: ExcelParser.normalizeClassNumber(row[normalized['Áè≠ÂÖßËôüÁ¢º']] || ''),
      gender: ExcelParser.normalizeGender(row[normalized['ÊÄßÂà•']] || ''),
      phone: ExcelParser.sanitizeString(row[normalized['ÈõªË©±']] || ''),
      email: ExcelParser.sanitizeString(row[normalized['ÈõªÈÉµ']] || ''),
      address: ExcelParser.sanitizeString(row[normalized['Âú∞ÂùÄ']] || ''),
    };

    // Remove empty fields
    Object.keys(student).forEach(key => {
      if (student[key] === '' || student[key] === null || student[key] === undefined) {
        delete student[key];
      }
    });

    return student;
  },

  /**
   * Sanitize string input to prevent injection attacks
   */
  sanitizeString: input => {
    if (typeof input !== 'string') {
      return normalizeString(String(input || ''));
    }

    // Remove potentially dangerous characters and normalize
    const sanitized = input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove script tags
      .replace(/javascript:/gi, '') // Remove javascript: protocol
      .replace(/on\w+\s*=/gi, '') // Remove event handlers
      .trim();

    return normalizeString(sanitized);
  },

  /**
   * Normalize grade to HK standard format (P1-P6, S1-S6)
   */
  normalizeGrade: rawGrade => {
    if (!rawGrade || typeof rawGrade !== 'string') return null;

    const grade = normalizeString(rawGrade);

    // Try direct mapping first
    if (GRADE_MAP[grade]) {
      return GRADE_MAP[grade];
    }

    // Try pattern matching with security checks
    const patterns = [
      { regex: /^(Â∞è|primary|p)([1-6])$/i, transform: match => `P${match[2]}` },
      { regex: /^(‰∏≠|secondary|s)([1-6])$/i, transform: match => `S${match[2]}` },
      { regex: /^([PS])([1-6])$/i, transform: match => `${match[1].toUpperCase()}${match[2]}` },
    ];

    for (const pattern of patterns) {
      const match = grade.match(pattern.regex);
      if (match) {
        return pattern.transform(match);
      }
    }

    console.warn('[ExcelParser] ‚ö†Ô∏è ÁÑ°Ê≥ïÊ®ôÊ∫ñÂåñÂπ¥Á¥ö:', rawGrade);
    return ExcelParser.sanitizeString(rawGrade); // Return sanitized original if can't normalize
  },

  /**
   * Normalize class number to safe integer
   */
  normalizeClassNumber: rawNumber => {
    if (!rawNumber) return null;

    // Convert to string first for safety
    const str = String(rawNumber).trim();

    // Extract numbers only
    const numbers = str.replace(/[^\d]/g, '');

    if (!numbers) return null;

    const num = parseInt(numbers, 10);

    // Validate range for security
    if (isNaN(num) || num < 1 || num > 50) {
      console.warn('[ExcelParser] ‚ö†Ô∏è Áè≠ÂÖßËôüÁ¢ºË∂ÖÂá∫ÁØÑÂúç:', rawNumber);
      return null;
    }

    return num;
  },

  /**
   * Normalize gender with validation
   */
  normalizeGender: rawGender => {
    if (!rawGender || typeof rawGender !== 'string') return null;

    const gender = normalizeString(rawGender).toLowerCase();
    const genderMap = {
      Áî∑: 'male',
      Â•≥: 'female',
      male: 'male',
      female: 'female',
      m: 'male',
      f: 'female',
      ÂÖ∂‰ªñ: 'other',
      other: 'other',
    };

    return genderMap[gender] || null;
  },

  /**
   * Infer school type from explicit type or student grades
   */
  inferSchoolType: (explicitType, students) => {
    // Use explicit type if available and normalize it
    if (explicitType && typeof explicitType === 'string') {
      const type = normalizeString(explicitType).toLowerCase();
      if (type.includes('Â∞èÂ≠∏') || type.includes('primary')) return 'primary';
      if (type.includes('‰∏≠Â≠∏') || type.includes('secondary')) return 'secondary';
      if (
        type.includes('ÁâπÊÆä') ||
        type.includes('ÁâπÊ†°') ||
        type.includes('sen') ||
        type.includes('special') ||
        type.includes('Á∂úÂêà')
      )
        return 'special';
    }

    // Infer from student grades
    const grades = students
      .map(s => s.grade)
      .filter(g => g && typeof g === 'string' && (g.startsWith('P') || g.startsWith('S')));

    if (grades.length === 0) return 'primary'; // Default

    const hasPrimary = grades.some(g => g.startsWith('P'));
    const hasSecondary = grades.some(g => g.startsWith('S'));

    if (hasPrimary && hasSecondary) return 'special';
    if (hasSecondary) return 'secondary';
    return 'primary';
  },

  /**
   * Generate duplicate hints for students within the same school
   */
  generateDuplicateHints: students => {
    if (!Array.isArray(students)) return [];

    return students.map((student, index) => {
      const duplicates = [];

      // Check for potential duplicates
      for (let i = index + 1; i < students.length; i++) {
        const other = students[i];

        // Name similarity
        if (student.name && other.name && student.name === other.name) {
          duplicates.push({
            type: 'name',
            otherIndex: i,
            reason: 'ÂßìÂêçÁõ∏Âêå',
          });
        }

        // Class number collision
        if (
          student.grade &&
          other.grade &&
          student.class &&
          other.class &&
          student.classNumber &&
          other.classNumber &&
          student.grade === other.grade &&
          student.class === other.class &&
          student.classNumber === other.classNumber
        ) {
          duplicates.push({
            type: 'class_collision',
            otherIndex: i,
            reason: 'Âπ¥Á¥ö„ÄÅÁè≠Âà•„ÄÅÁè≠ÂÖßËôüÁ¢ºÁõ∏Âêå',
          });
        }
      }

      return {
        ...student,
        duplicateHint: duplicates.length > 0 ? duplicates : null,
        duplicateResolution: duplicates.length > 0 ? 'pending' : null,
      };
    });
  },
};

export default ExcelParser;
